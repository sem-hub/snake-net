* Для всего приложения: сделать logger индивидуальный для каждого модуля с настройкой уровня логирования
* Убрать panic() из tun.go
* Список клиентов теперь можно сделать в sync.Map
* Вместо rand.Intn использовать crypto/rand для генерации паддинга
* Проверять подпись пакета до расшифровки
* Разобраться с ошибками при обмене: как отключать клиентов, как понимать что клиент отключился и пр.
* Отложенное подключение клиентов, когда сервер не отвечает сразу.
* encryption с выбором алгоритма (динамический выбор при согласовании)

* Попробовать использовать bytes.Buffer

* Поменять maps на sync.Map
* Попробовать использовать sync.Pool для уменьшения аллокаций
* когда-нибудь сделать не разделение на клиент и сервер, а просто узлы, которые могут быть и тем и другим

Блочные шифры, которые можно использовать в решиме поточных шифров:
* AES в режиме CTR
* в режиме OFB
* в режиме CFB
* ChaCha20
* Salsa20
Вместо шифрования с подписью можно использовать шифрование с аутентификацией (AEAD):
* AES в режиме GCM
* ChaCha20-Poly1305 (быстрее AES)
* XSalsa20-Poly1305
* AES-SIV
* AES-PMAC-SIV
* AES-EAX
* AES-OCB
* AES-CCM
* AES-GCM-SIV
